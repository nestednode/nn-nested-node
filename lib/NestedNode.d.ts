import Direction = require('./Direction');
import NestedNodeRegistry = require('./NestedNodeRegistry');
import NestedData = require('./NestedData');
declare class NestedNode<D extends NestedData<any>> {
    private registry;
    private _id;
    id: string;
    private _parent;
    parent: NestedNode<D>;
    hasParent: boolean;
    root: NestedNode<D>;
    level: number;
    private _nested;
    nested(index: number): NestedNode<D>;
    firstNested: NestedNode<D>;
    lastNested: NestedNode<D>;
    nestedCount: number;
    mapNested<T>(cb: (node: NestedNode<D>) => T, thisArg?: any): T[];
    forEachNested(cb: (node: NestedNode<D>) => void, thisArg?: any): void;
    forEachNestedDeep(cb: (node: NestedNode<D>) => void): void;
    traverse(cb: (node: NestedNode<D>) => void): void;
    getSibling(direction: Direction, sameParentOnly?: boolean, preferredLevel?: number): NestedNode<D>;
    private getImmediateSibling(direction);
    private getCrossSibling(direction, preferredLevel);
    private getCrossSiblingPhase2(direction, preferredLevel);
    data: D;
    forEachNestedData(cb: (data: D, key) => void, thisArg?: any): void;
    mapNestedData<T>(cb: (data: D, key) => T, thisArg?: any): T[];
    appendNested(node: NestedNode<D>, anchorNode?: NestedNode<D>, direction?: Direction): void;
    removeNested(node: NestedNode<D>): void;
    replaceNested(node: NestedNode<D>, newNode: NestedNode<D>): void;
    attachToParent(parent: NestedNode<D>): void;
    makeParentless(): void;
    substituteFor(newNode: NestedNode<D>): void;
    private _selected;
    selected: boolean;
    select(ensureNestedUnselected?: boolean): void;
    unselect(): void;
    unselectDeep(): void;
    getSelection(): NestedNode<D>[];
    constructor(registry: NestedNodeRegistry<any>, data: D, dataDuplicator: (src: D) => D);
}
export = NestedNode;
