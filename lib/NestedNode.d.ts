import SequenceDirection = require('./SequenceDirection');
declare class NestedNode {
    private _selected;
    selected: boolean;
    select(ensureNestedUnselected?: boolean): void;
    unselect(): void;
    unselectDeep(): void;
    getSelection(): NestedNode[];
    private _parent;
    parent: NestedNode;
    hasParent: boolean;
    root: NestedNode;
    level: number;
    private _nested;
    nested(index: number): NestedNode;
    firstNested: NestedNode;
    lastNested: NestedNode;
    nestedCount: number;
    getSibling(direction: SequenceDirection): NestedNode;
    getSiblingWide(direction: SequenceDirection, preferredLevel: number): NestedNode;
    private getSiblingWidePhase2(direction, preferredLevel);
    getPreceding(preferredLevel?: number): NestedNode;
    getFollowing(preferredLevel?: number): NestedNode;
    eachNested(cb: (node: NestedNode, key: number) => void): void;
    eachNestedDeep(cb: (node: NestedNode) => void): void;
    each(cb: (node: NestedNode) => void): void;
    appendNested(node: NestedNode, anchorNode?: NestedNode, direction?: SequenceDirection): void;
    removeNested(node: NestedNode): void;
    replaceNested(node: NestedNode, newNode: NestedNode): void;
    attachToParent(parent: NestedNode, anchorNode?: NestedNode, direction?: SequenceDirection): void;
    makeParentless(): void;
    substituteFor(newNode: NestedNode): void;
    duplicate(): NestedNode;
    constructor(ref?: NestedNode);
    protected init(): void;
    protected clone(ref: NestedNode): void;
    getCopy(): NestedNode;
}
export = NestedNode;
